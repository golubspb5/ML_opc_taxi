# **MLOps Project: Taxi App CI/CD**

Данный проект реализует полный цикл CI/CD для ML-сервиса предсказания стоимости поездки на базе FastAPI.
Пайплайн включает автоматическое тестирование, обучение модели, сборку Docker-образов и деплой с использованием стратегии Blue-Green, обеспечивающей обновление без простоя.

## Пример работы сервиса

![Пример работы сервиса](assets/predict.png)

Сервис развёрнут на локальной виртуальной машине, доступ к нему осуществляется через внутреннюю сеть (NAT, 8080 → 80). Внешнего доступа нет, но инфраструктура полностью идентична production-окружению.

---
# 1. Архитектура проекта

Проект представляет собой ML-сервис, включающий следующие компоненты:

### ML-часть

* Датасет `uber.csv`
* Скрипт обучения модели `train_and_save_model.py`
* Полученная модель `model.pkl`
* API-логика на FastAPI:
  * `/` — health-check
  * `/api/predict/` — точка предсказания на основе обученной модели

### Инфраструктура

* CI/CD пайплайн GitFlic Runner
* Docker-образ приложения
* docker-compose
* Nginx как reverse-proxy
* Две параллельные ревизии приложения:
  * `app_blue` 
  * `app_green`
* Автоматизированный скрипт деплоя `deploy.sh`

## Пример успешного CI/CD пайплайна

![Пример успешного CI/CD пайплайна](assets/pipe.png)

---
# 2. Архитектура CI/CD пайплайна

Пайплайн состоит из шести основных стадий:

## 2.1. Lint
 
**Цель:** статический анализ кода.

Проверяется:

* корректность Python-кода
* соответствие стиль-гайдам
* отсутствие неиспользуемых импортов
* базовая типизация

## 2.2. Smoke Tests

**Цель:** минимальная проверка API без обучения модели.

Проверяется:

* что FastAPI приложение импортируется
* что эндпоинты существуют
* что сервис "отвечает", даже если модель отсутствует

Для этого используется фиктивный mock-объект вместо модели.

## 2.3. Unit Tests

**Цель:** проверка правильности бизнес-логики и обработки данных.

Проверяются:

* функции преобразования данных
* edge-кейсы
* корректность структуры ответа

Ошибки блока означают, что модель будет обучена на некорректных данных.

## 2.4. Train Model

**Цель:** полноценное обучение ML-модели.

Выполняется:

* загрузка исходного датасета
* предобработка
* разделение train/test
* обучение `LinearRegression`
* сохранение `model.pkl`
* генерация метрик
* сохранение артефактов в CI/CD

Результат обучения используется в следующих стадиях.

## 2.5. Build & Push

**Цель:** сборка финального Docker-образа.

Создаётся образ вида:

```
registry.gitflic.ru/project/.../app:<commit_sha>
```

И пушится в registry.

## 2.6. Integration Tests

**Цель:** проверить API в реальном Docker-окружении.

1. Собирается временный Docker-образ (`api-test`)
2. Контейнер запускается в фоне с портом 32000
3. Запускаются реальные HTTP-запросы через `pytest + requests`
4. Проверяются:

   * `/` health-check
   * `/api/predict/`
   * корректность формата ответов
   * корректность работы модели

## 2.7. Blue-Green Deploy

**Цель:** зависимое от image-тега развёртывание приложения на ВМ с нулевым простоем.

Этап выбирает, какая ревизия будет новой, запускает её, проверяет health и переключает nginx-прокси.

---
# 3. Blue-Green Deployment

## 3.1. Назначение

Blue-Green деплой предназначен для обновления приложения без остановки сервиса.

Схема:

* одновременно существуют две версии приложения: **BLUE** и **GREEN**
* одна версия получает весь трафик
* новая версия запускается параллельно
* после успешной проверки трафик переключается на неё
* старая гасится

## 3.2. Архитектура Blue-Green

В docker-compose определены две службы:

```
app_blue  → порт 5001
app_green → порт 5002
```

nginx маршрутизирует трафик через `upstream.conf`:

```
upstream ml_upstream {
    server ml-app-blue:32000 max_fails=5 fail_timeout=5s;
}
```

или

```
upstream ml_upstream {
    server ml-app-green:32000 max_fails=5 fail_timeout=5s;
}
```

## 3.3. Деплой

Развертывание приложения организовано по схеме *blue-green*, благодаря которой новая версия поднимается параллельно текущей рабочей, не влияя на пользователей. На сервере постоянно существуют две ревизии приложения — **blue** и **green**. В каждый момент времени только один цвет обслуживает трафик, а второй служит резервным.

Когда Gitflic доходит до стадии `deploy`, пайплайн передаёт скрипту `deploy.sh` хеш текущего коммита. Этот хеш становится тегом Docker-образа, который должен быть задеплоен. Деплой всегда выполняется в постоянной директории `/opt/uber`, куда CI предварительно синхронизирует файлы.

I. `deploy.sh` анализирует файл `nginx/nginx/upstream.conf`, чтобы определить, какой цвет в данный момент активен. Если активен `blue`, новый выкат пойдёт в слот `green`, и наоборот. Это гарантирует, что обновляется именно резервный цвет, а не тот, через который сейчас идёт трафик.

II. Удаляется контейнер нового цвета, если он неожиданно сохранился от предыдущего деплоя. После очистки выполняется загрузка соответствующего образа из Docker Registry и поднятие контейнера нового цвета через `docker compose`. 

III. В течение нескольких попыток скрипт проверяет состояние контейнера через:

```
docker inspect .State.Health.Status
```

Если контейнер достигает состояния `"healthy"`, деплой продолжается. Иначае -  останавливается: контейнер нового цвета выключается, а рабочая версия продолжает обслуживать пользователей без простоя.

IV. Переключение трафика. В директории `nginx/nginx` заранее лежат два шаблона — `upstream_blue.tmpl` и `upstream_green.tmpl`. Каждый шаблон указывает на контейнер соответствующего цвета (`app_blue` или `app_green`). Скрипт копирует нужный шаблон в рабочий файл `upstream.conf`, который читает Nginx. Затем выполняется мягкая перезагрузка прокси внутри контейнера:

```
nginx -s reload
```

Перезагрузка не прерывает текущие соединения и не вызывает downtime: новые запросы мгновенно перенаправляются на только что развернутую версию.

Когда трафик переключён, контейнер старого цвета останавливается, а новый становится активной рабочей версией, а его цвет — новым текущим цветом для следующего цикла деплоя.

---

## 3.4. Rollback

В проекте реализован двухуровневый механизм rollback, который обеспечивает безопасное обновление сервиса и предотвращает попадание неработоспособной версии в продакшен. Откат происходит автоматически и срабатывает в двух разных моментах процесса деплоя — сначала до переключения трафика, а затем и после него, если возникают проблемы уже на уровне проксирования.
 
Первый уровень защиты работает ещё до того, как новая версия получает трафик. Сразу после запуска контейнера в резервном слоте скрипт начинает следить за его состоянием через Docker-healthcheck. Контейнер обязан перейти в состояние healthy, что означает успешный запуск FastAPI, загрузку модели, поднятие сервера и готовность принимать запросы. 

Если контейнер остаётся в состоянии starting или unhealthy в течение заданного времени, деплой автоматически прекращается. Новый контейнер останавливается, рабочая версия продолжает обслуживать пользователей, а пайплайн завершается ошибкой. 

Второй уровень отката срабатывает уже после того, как новая версия прошла healthcheck и Nginx был переключён на ревизию нового цвета.

После reload Nginx скрипт выполняет дополнительную внешнюю проверку — делает запрос к корню сервиса через http://localhost/. Если Nginx возвращает ошибку или соединение сбрасывается, скрипт автоматически выполняет rollback: возвращает предыдущий файл upstream.conf, перезагружает Nginx ещё раз и отключает контейнер новой версии. Сервис мгновенно возвращается на стабильную рабочую ревизию.

## Пример Rollback-а

![Пример Rollback-а](assets/trafic_switch.png)

---

# 4. Локальный запуск проекта

## 4.1. Установка проекта

```
git clone https://gitflic.ru/project/golubspb5/ml-opc-taxi.git
cd ml-opc-taxi

python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

## 4.2. Обучение модели

```
python src/service/train_and_save_model.py --csv src/uber.csv --output src/service/model.pkl
```

## 4.3. Запуск FastAPI

```
uvicorn src.service.main:app --host 0.0.0.0 --port 32000
```

---

# 5. Проверка работающего сервиса

### Health-check

```
curl http://localhost/
```

### Предсказание

```
curl -X POST http://localhost/api/predict/ \
-H 'Content-Type: application/json' \
-d '{"data":[{"pickup_latitude":70.15,"pickup_longitude":-40.22,"dropoff_latitude":70.83,"dropoff_longitude":-1.0,"passenger_count":2}]}'
```
